
실시간으로 따라오면서 어떻게 하는지 그 길을 뚫는 것이 목적인 강의

하다가 안되면 되고 있다고 믿으십시다.

버전관리 시스템?
- 원본을 수정하지 않고 원본의 복제본
- 논문 작업했을때 버전관리 경험하고 똑같긴함.
	- 파일이 많아지고 지저분하고, 용량이 크고, 뭐가 바뀌었는지 헷갈리는 경우가 있었음.

버전 -> 백업 -> 협업

개발자가 만들어서...
- 사용성 안좋음

깃은 원리를 배우는 것이 가장 가성비가 좋은 행동.
- 복잡한데 단순함.

이해가 안가면 수업을 찾지말고 직접 해봐라.
- gpt한테 구조 물어보면서  해라.


공부란 해서 내 삶이 좋아져야 하는것.
- 내 프로젝트는 리눅스 처럼 크다 라고 생각합시다.



## 버그
희망편 : 문법
절망편 : 논리  

버전 관리의 목적은 디버깅이다
- 디버깅을 못하면 버전 관리를 못하고 있는 것이다.

좋은 버전은 하나의 버전에 하나의 주제, task를 가지고 있는 것
- 너무 많은 변경사항을 가지고 있지 않아야 함.
- 단위작업에서

맨 처음 repository 만들때
- 폴더 안에 내용을 만드는 이유 
- ![[Pasted image 20231128115016.png]]
- 이렇게 되기 때문에

working dir : 사람이 작업
.git : 기계의 영역

git commit
- 내용을 기반으로 식별자를 생성
- 비트코인도 같은 원리

head : 현재
main/master : 마지막 버전


v1에 txt1이 있는데
v2로 새롭게 commit하면 v1,v2,v3가 병합된 새로운 repository 생성
- 이때, parent는 head에 해당하는 commit id값
- 커밋할때 이름을 지정하는 건 내가 보기 편하라고 해놓은거고, 실제 컴퓨터에 저장되는건 id값
![[Pasted image 20231128132825.png]]

각각의 commit은 commit한 시점의 stage area의 snapshot이다


b로 가서 작업하고 싶다
- head를 b로 옮김

여기에서 head가 c를 직접 지정한다
## detached head state
- 각 commit에 대한 지식이 없으면 작업을 날릴 가능성이 높음.
- 이 상황에서는 계속 경고를 보냄.
- 새로 d를 커밋하면 head만 d로 옮겨감
- 그럼 나중에 main으로 돌아간다면?
	- 끼야악
- 테스트용으로는 괜찮은 기능.
- 만약 commit id를 종이에다가 적어놨다면 어떻게든 복구는 되겠지.

모든 중심은 head!
- 그래프를 보면 먼저 헤드를 찾읍시다
- 여기서 main이 e로 옮기는 방법은?
- detached된 상황이 두렵다 : 해당 commit id를 적어둡시다. 0de4b65d9ecea162b506b102e5858a890160ba7f

## 불변성 : 깃은 어떤 버전도 지우지 않고, 수정하지 않음.
- 반드시 복원가능.
- commit id가 필요
- 복원
	- .git폴더 자체를 백업
	- commit id를 외워뒀다가 집어넣기

checkout, reset
- checkout : head를 옮김
- reset : branch를 옮김


## Branch
![[Pasted image 20231128150420.png]]
- head가 움직이는 부분 == main이 움직이게됨



## Base
- 서로 같은 뿌리에서 나올 경우 공통의 조상이라고 할 수 있는 Base를 기준으로 변경사항에 대해 비교 후 병합.
![[Pasted image 20231128151223.png]]
- 따라서 이 경우는 1,m2,e3,??가 됨.
- 둘 다 수정될 경우 head는 m4인데 e4로 바꿀래?라는 선택지를 줌.
	- m4e4, m4, e4 선택 가능

바이너리는 항상 충돌난다고 생각.
base를 지정할 수는 있겠지만, 굳이?

복습방법
- 동영상 마지막 전체 빠르게 복습있음